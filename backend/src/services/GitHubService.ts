import { Octokit } from '@octokit/rest';
import type { GitHubIssue, GameConfig } from '../types/index.js';
import { logger } from '../utils/logger.js';

export class GitHubService {
  private octokit: Octokit | null = null;
  private config: GameConfig | null = null;

  configure(config: GameConfig): void {
    this.config = config;
    this.octokit = new Octokit({
      auth: config.pat,
    });
    logger.info(`GitHubService configured for ${config.owner}/${config.repo}`);
  }

  isConfigured(): boolean {
    return this.octokit !== null && this.config !== null;
  }

  getConfig(): GameConfig | null {
    return this.config;
  }

  async fetchIssues(): Promise<GitHubIssue[]> {
    if (!this.octokit || !this.config) {
      throw new Error('GitHubService not configured');
    }

    try {
      const { data } = await this.octokit.issues.listForRepo({
        owner: this.config.owner,
        repo: this.config.repo,
        state: 'open',
        per_page: 100,
      });

      // Filter out pull requests (GitHub API returns PRs as issues too)
      const issues = data.filter((issue) => !issue.pull_request);

      return issues.map((issue) => ({
        id: issue.id,
        number: issue.number,
        title: issue.title,
        body: issue.body || '',
        labels: issue.labels.map((label) =>
          typeof label === 'string' ? label : label.name || ''
        ),
        state: issue.state as 'open' | 'closed',
        url: issue.html_url,
      }));
    } catch (error) {
      logger.error('Failed to fetch issues', error);
      throw error;
    }
  }

  async getIssue(issueNumber: number): Promise<GitHubIssue | null> {
    if (!this.octokit || !this.config) {
      throw new Error('GitHubService not configured');
    }

    try {
      const { data: issue } = await this.octokit.issues.get({
        owner: this.config.owner,
        repo: this.config.repo,
        issue_number: issueNumber,
      });

      return {
        id: issue.id,
        number: issue.number,
        title: issue.title,
        body: issue.body || '',
        labels: issue.labels.map((label) =>
          typeof label === 'string' ? label : label.name || ''
        ),
        state: issue.state as 'open' | 'closed',
        url: issue.html_url,
      };
    } catch (error) {
      logger.error(`Failed to fetch issue #${issueNumber}`, error);
      return null;
    }
  }

  async createPullRequest(
    branchName: string,
    issueNumber: number,
    issueTitle: string
  ): Promise<string> {
    if (!this.octokit || !this.config) {
      throw new Error('GitHubService not configured');
    }

    try {
      // Get the default branch
      const { data: repo } = await this.octokit.repos.get({
        owner: this.config.owner,
        repo: this.config.repo,
      });

      const { data: pr } = await this.octokit.pulls.create({
        owner: this.config.owner,
        repo: this.config.repo,
        title: `Fix: ${issueTitle}`,
        head: branchName,
        base: repo.default_branch,
        body: `This PR was automatically generated by the RTS Issue Battle game to fix issue #${issueNumber}.\n\nCloses #${issueNumber}`,
      });

      logger.info(`Created PR #${pr.number} for issue #${issueNumber}`);
      return pr.html_url;
    } catch (error) {
      logger.error(`Failed to create PR for issue #${issueNumber}`, error);
      throw error;
    }
  }

  getCloneUrl(): string {
    if (!this.config) {
      throw new Error('GitHubService not configured');
    }
    // Use PAT in clone URL for authentication
    return `https://${this.config.pat}@github.com/${this.config.owner}/${this.config.repo}.git`;
  }
}

// Singleton instance
export const githubService = new GitHubService();
